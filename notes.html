<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="notes_files/libs/clipboard/clipboard.min.js"></script>
<script src="notes_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="notes_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="notes_files/libs/quarto-html/popper.min.js"></script>
<script src="notes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="notes_files/libs/quarto-html/anchor.min.js"></script>
<link href="notes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="notes_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="notes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="notes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="notes_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>Hi everyone welcome to my progress review presentation</p>
<p>Hi everyone, How’s everyone doing today? Anyone here feeling like they won the lottery? Good well I’m about to tell the story of how I spent an entire year trying to fit neural networks with the worse luck possible, and how I was finally able to win the neural network lottery by veeery slim chances</p>
<p>Without further ado, let’s jump right into it. Those of you who were here in last year’s presentation would be very much familiar with what i’m about to say, but let’s be honest here. Building a good model is hard yes, but explaining a good model is even harder.</p>
<p>For example let’s take this lil guy. A happy good looking model, we can’t see what’s happening inside it but we can prod the model and see how it responds to different scenarios through a set of methods called explainable AI methods.</p>
<p>XAI methods are classified based on two parts, firstly whether they are model specific or model agnostic, and then whether the method is explaining the behavior of the model with respect to the entire dataset or how the model reacts to a specific observation.</p>
<p>Let’s start things off by focusing on model agnostic local interpretability methods. Because most of the times we want personalized explanations instead of global explanations which might be harder to understand.</p>
<p>There are several XAI methods that fit into that category as seen here. Each method has its own method of answering a very specific aspect of the model. But there’s something missing here.</p>
<p>Each of these methods are giving us a bunch of numbers and it doesn’t make sense to look at these numbers as they are. So what if instead of looking at these numbers outside of the model and the data space we built geometric representations to draw these numbers on the model data space.</p>
<p>Let’s see how we can do that, starting off first with LIME. LIME tries to answer the question “How important were each of the features in giving this prediction” and the way LIME tries to answer it is by going “If only we could have super simple model that acts similar to the original black box model near a local neighborhood of the given observation, then we can try to see the importance of each feature by fitting that small model into a bunch of simulated data points within that neighborhood.” In the actual implementation LIME uses a simple generalized linear model around the local neighborhood and returns the coefficients of the model as feature importances. Therefore to visualize values from LIME we can use regression lines like this.</p>
<p>SHAP values on the other hand, answer the question, “How much did every feature contribute to the final prediction”. Simply put SHAP values consider each feature as a co-op game and the final prediction as the reward. Then several perturbations of the dataset is made by adding and removing features to see the influence each feature has on the prediction. Therefore to represent SHAP values we use force vectors along the axis of a feature to represent the. Therefore to represent SHAP values we use force vectors along the axis of a feature to represent them</p>
<p>Counterfactual values aim to answer the question “How much should the features change for the prediction to change”. This question is then reframed as an optimization problem to find the closest feature with the least amount of changes that have the desired prediction from the model. Since Counterfactuals show the counter example from the dataset we can use connecting lines to visualize them in the data space.</p>
<p>Finally we have Anchors, and anchors tries to answer the question, “Where are observations located with the same predictions as the target observation of interest?” It’s done by formulating the problem as a multiarm bandit problem to find boundaries that contain of the observations that have the same prediction as the given observation. Intuitively, we can draw anchors as bounding boxes around the given observation.</p>
<p>At the time I was working on proposing these representations, the active anchors package was quite hard to debug and was quite buggy. Therefore as a solution I introduced the kultarr package that also has options to visualise the created anchors as well.</p>
<p>To wrap up, these are the proposed geometric representations of the XAI methods in summary.</p>
<p>So far the examples that we gave were in two dimensions, but in the real world datasets will have a large number of features and to visualize this large number of features while also allowing the user to select the observations that they want to explain, we made some improvements to detourr.</p>
<p>Combining everything we have worked on the first year, we created a small shiny app to explore and understand a model, the data and the explanations all in one place.</p>
<p>This shiny app was then packaged into an R package called Rosella, which is still under development.</p>
<p>Now that’s done, shall we join a cult. Everyone’s talking about LLMs and deep learning these days. Let’s have a raise of hands who spoke with an LLM already today?</p>
<p>So earlier we talked about model agnostic XAI methods, but in reality when it comes to neural networks, simply prodding and poking the model wont tel you much about the model unless you open the model up and look at the internals</p>
<p>So let’s fit a neural network, specifically for this dataset.</p>
<p>Now for a quick refresher on how neural networks are fitted.</p>
<p>A neural network is a combination of linear transformations where each is followed by a non linear function. We have a set of input features and a hidden layer and an output layer as the basic setup. A hidden layer consists of units called neurons which contain a weight for each of the unit of the previous layer and a bias variable which is added to create the output of the neuron. This output is then sent through a non linear function such as ReLU to ensure that the signal passes through a neuron once a certain threshold is reached. Now these weights are learned by performing a forward pass to obtain the prediction from the model and then comparing it with the ground truth to obtain a loss. This loss is then used to calculate the gradient with respect to each weight to have a sense of how much the loss is influenced by each weight. Then using a learning rate we update the weights iteratively through several epochs. And once that’s set we let it run and et voila we have a neural network. Notice how I set arbitrary set of hyperparameters without thinking and the model learned the decision boundary somewhat well?<br>
That’s something we are going to talk about soon.</p>
<p>Now back to where we left things at,</p>
<p>Let’s fix some hyperparams for the plot, but I am a benovelent democratic presenter I will let everyone here and online to vote on how many neurons we should use for that dataset we just saw. Specifically this dataset.</p>
<p>Now based on the results we are going to see who got the best fit on the model.</p>
<p>So was this the result you wanted to see? Think again, there’s more than answer to the result. All of these are possible models for the given neural network architecture</p>
<p>Let’s take a second to look at it more intently, These are the worst performing models based on the F1 score for each of the neuron levels. Now let’s take a look at the best of each. Notice how the best of 5 and 8 neurons is capable of being closely fitting as the 30 neuron model. But let’s take a look at the entire spread. Now here’s where my story comes into play. I was somewhere here. Basically, in the worst of the bunch.</p>
<p>So any guesses what happened?</p>
<p>The answer is simple.</p>
<p>I was using the wrong random seed. I was fixing everything else in the model but never thought or saw anywhere that the random seed might have been the problem</p>
<p>But how could that be? Well for starters the initial weights has an effect on the optimization problem. This has been mentioned in techniques such as MAML for few shot training where a neural network is trained to generalize among multiple tasks by trying to find a common initial weight.</p>
<p>Well this was a fun story but why does it matter?</p>
<p>I could have just chucked a 20 neuron model when it didn’t work at the first instance and called it a day. I would be presenting something completely different today if I went with that. But take a look at this dataset. Do we really need 20 * 2 + 20 + 20 + 20 = 100 parameters when 5 * 2 + 5 + 5 + 5 = 25 parameters can do the job. More than 4 times more parameters</p>
<p>So I went back to where most of the issues came from. We are not talking about how training neural networks are more like winning the lottery. Every LLM you see out there has to go through multiple restarts, better initializations and many more tricks to make sure that the result is a good working model. To make sure I raise awareness about this, I decided to start from the place that this needs to be talked about from, the educators. And for that I created this application and you get to be the second batch of students that experience this application.</p>
<p>Things to talk about in the app.</p>
<p>The tutorial to get the students close to the concept about to be taught, the application divided into several parts. The squiggler tool allowing us to move and add new nodes. The ability to select neurons to test and how many replicates per neuron. Then the model fit monitoring. and the resulting spread, being able to select individual models and seeing the fit. seeing the gif of spread.</p>
<p>The backend consists of multiple technologies as shown here.</p>
<p>The methodology is quite simple, we made sure to generate the dataset using a fixed seed, and we randomly sampled (using cryptographically safe randomly generated) seeds between a wide range and used that to create replicates of the model.</p>
<p>Now where to from here?</p>
<p>We have probably heard of the attention is all you need paper a million times now, at least I have and but did we need this many parameters to work with llms?</p>
<p>As the third and final project I aim to work on top of a toy transformer model to understand what are the internal circuits that a transformer learns through the training process? Does grokking happen etc. These days I’m working on developing transformers from scratch to obtain a more ground up understanding instead of using readily available models like gpt-2</p>
<p>The time line looks like this</p>
<p>As it is tradition, the slide color palette was inspired by this photograph in the Hellenic Museum in Flagstaff here in Melbourne when I was filming a documentary there for a film festival during my break.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>